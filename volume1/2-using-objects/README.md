# Making & Using Objects

* Process of language translation
  * Interpreters
  * Compilers
* Declaration vs Definition

## Process of language translation

### Interpreters

Interpreter translates source dode into activities (which may comprise groups of machine instructions) and immediately executes those activities.

Interpreters have many advantages. The transition from writing code to executing code is almost immediate, and the source code is always available so the interpreter can be much more specific when an error occurs. The benefits often cited are __ease of interaction__ and __rapid development__ of programs.

Interpreted languages often have severe limitations when building large projects. The __interpreter must always be in memory to execute the code__, and even the fastest interpreter __may introduce unacceptable speed restrictions__. Most interpreters require that __the complete source code be brought into the interpreter all at once__. Not only does this introduce a space limitation, it can also cause more difficult bugs if the language doesn't provide facilities to localize the effect of different pieces of code.

### Compilers

Compiler translates source code directly into assembly language or machine instructions. The eventual end product is a file or files containing machine code. This is an involved process, and usually takes several steps.

Programs generated by a compiler __tend to require much less space to run__, and they __run much more quickly__. Some languages (such as C) are designed to __allow pieces of a program to be compiled independently__. These pieces are eventually combined into a final _executable_ program by a tool called the __linker__. This process is called __separate compilation__.

Separate compilation has its many benefits. Programs can be built and tested one piece at a time and treated as a building block. Collections of tested and working pieces can be combined into _libraries_ for use by other programmers. As each piece is created, the complexity of the other pieces is hidden.

Compiler __debugging features__ have improved significantly over time. Modern compilers can insert information about the source code into the executable program and this information is used by powerful _source-level debuggers_ to show exactly what is happening in a program by tracing its process through the source code.

#### Compilation Process

Some languages (C and C++ in particular) start compilation by running a __preprocessor__ on the source code. The _preprocessor_ is a simple program that __replaces patterns in the source code with other patterns the programmer has defined__ (using _preprocessor directives_). The pre-processed code is often written to an intermediate file.

Compilers usually do their work in two phgases. The __first pass parses the pre-processed code__. The compiler breaks the source code into small units and organizes it into a structure called a __tree__.

A __global optimizer__ is sometimes used between the first and second passes to produce smaller, faster code.

In the second pass, the __code generator walks through the parse tree and generates either assembly language code or machine code__ for the nodes of the tree. If the code generator creates assembly code, the assembler must then be run. The __end result__ in both cases is an __object module__ (a file that typically has an extension of `.o` or `.obj`).

A _peephole optimizer__ is sometimes used in the second pass to look for pieces of code containing redundant assembly-language statements.

The __linker combines a list of object modules into an eecutable__ program that can be loaded and run by the operating system. When a function in one object module makes a reference to a function or variable in another object module, the linker resolves these references, it makes sure that all the external functions and data you claimed existed during compilation do exist. The __linker also adds a special object module to perform start-up activities__.

The __linker can search through special files called libraries in order to resolve all its references__. A library contains a collection of object modules in a single file. A library is created and maintained by a program called a __librarian__.

#### Static type checking

The compiler performs __type checking__ during the first pass. Type checking tests for the proper use of arguments in functions and prevents many kinds of programming errors.

Since it happens during compilation instead of when the program is running, it is called _static type checking_.

#### Using libraries

1. Include library's header file (declarations).

2. Use the functions and variables in the library.

3. Link library into executable program.

## Declaration vs Definition

A __declaration introduces a name – an identifier – to the compiler__. It tells the compiler “This function or this variable exists somewhere, and here is what it should look like.” __A definition__, on the other hand, says: “Make this variable here” or “Make this function here.” It __allocates storage for the name__.

You can declare a variable or a function in many different places, but there must be only one definition in C and C++ (this is sometimes called the __ODR: one-definition rule__). When the linker is uniting all the object modules, it will usually complain if it finds more than one definition for the same function or variable.

A __definition can also be a declaration__. If the compiler hasn’t seen the name x before and you define `int x;`, the compiler sees the name as a declaration and allocates storage for it all at once.
